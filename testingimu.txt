#!/usr/bin/env python3
import asyncio
import json
import websockets
from datetime import datetime, UTC
import serial
import threading
import time
import random
import re
import math
import board
import busio
import sys
import os

# Adafruit BNO08x (version 1.2.4 structure)
from adafruit_bno08x.i2c import BNO08X_I2C
from adafruit_bno08x import BNO_REPORT_ROTATION_VECTOR


# ----------------------------------------------------------------------
# CONFIGURATION
# ----------------------------------------------------------------------
HOST = "0.0.0.0"                     # listen on all interfaces (Linux-friendly)
PORT = 2003
UPDATE_RATE_HZ = 1                   # 1-second updates everywhere

# ---------- LINUX USB-UART ----------
# First USB-UART device (ttyUSB0).  If you have more than one, change the index.
XBEE_PORT = "/dev/ttyUSB0"
XBEE_BAUD = 9600

# Fallback ports – useful if the device appears under a different name
FALLBACK_PORTS = [
    "/dev/ttyUSB1",
    "/dev/ttyACM0",
    "/dev/ttyACM1",
]

# ----------------------------------------------------------------------
# HIGH PRECISION QUATERNION → EULER
# ----------------------------------------------------------------------
def quaternion_to_euler(w, x, y, z):
    """Convert quaternion to Euler angles (roll, pitch, yaw) in radians"""
    norm = math.sqrt(w*w + x*x + y*y + z*z)
    if norm == 0 or math.isnan(norm):
        return None

    w /= norm
    x /= norm
    y /= norm
    z /= norm

    # Roll (x-axis)
    t0 = 2.0 * (w * x + y * z)
    t1 = 1.0 - 2.0 * (x*x + y*y)
    roll = math.atan2(t0, t1)

    # Pitch (y-axis)
    t2 = 2.0 * (w * y - z * x)
    t2 = max(min(t2, 1.0), -1.0)
    pitch = math.asin(t2)

    # Yaw (z-axis)
    t3 = 2.0 * (w * z + x * y)
    t4 = 1.0 - 2.0 * (y*y + z*z)
    yaw = math.atan2(t3, t4)

    return roll, pitch, yaw


# ----------------------------------------------------------------------
# GLOBAL STATE (thread-safe)
# ----------------------------------------------------------------------
class SystemState:
    def __init__(self):
        self.raw_pitch = 0.0
        self.raw_roll  = 0.0
        self.raw_yaw   = 0.0
        self.heading   = 280.0          # Fixed heading for gun_id 1

        # raw GNSS (simulated)
        self.latitude  = 28.6139
        self.longitude = 77.2090
        self.altitude  = 250.0

        # ZigBee corrections
        self.correction_x = 0.0
        self.correction_y = 0.0
        self.correction_z = 0.0

        self.gun_id = 1

        # Zero reference (SET button)
        self.zero_pitch = 0.0
        self.zero_roll  = 0.0
        self.zero_yaw   = 0.0

        self.lock = threading.Lock()

state = SystemState()

# Global ZigBee serial (shared for read/write)
ser = None

# Global BNO085 sensor
bno = None


# ----------------------------------------------------------------------
# REAL IMU (BNO085) READER
# ----------------------------------------------------------------------
def read_imu_data():
    global bno
    try:
        i2c = busio.I2C(board.SCL, board.SDA)
        bno = BNO08X_I2C(i2c)
        bno.enable_feature(BNO_REPORT_ROTATION_VECTOR)
        print("BNO085 IMU initialized successfully")
    except Exception as e:
        print(f"Failed to initialize BNO085: {e}")
        print("Falling back to simulated IMU data")
        while True:
            with state.lock:
                state.raw_pitch += random.uniform(-0.08, 0.08)
                state.raw_roll  += random.uniform(-0.08, 0.08)
                state.raw_yaw   += random.uniform(-0.08, 0.08)
                state.heading = 280.0
            time.sleep(0.01)
        return

    while True:
        try:
            q = bno.quaternion
            if q is None or len(q) != 4:
                time.sleep(0.01)
                continue

            w, x, y, z = q
            euler = quaternion_to_euler(w, x, y, z)
            if euler is None:
                time.sleep(0.01)
                continue

            roll, pitch, yaw = euler
            roll_deg  = math.degrees(roll)
            pitch_deg = math.degrees(pitch)
            yaw_deg   = math.degrees(yaw)

            with state.lock:
                state.raw_roll  = roll_deg
                state.raw_pitch = pitch_deg
                state.raw_yaw   = yaw_deg
                state.heading = 280.0

            time.sleep(0.01)          # 100 Hz sampling
        except Exception as e:
            print(f"Error reading IMU: {e}")
            time.sleep(0.1)


# ----------------------------------------------------------------------
# SIMULATED GNSS
# ----------------------------------------------------------------------
def read_gnss_data():
    while True:
        with state.lock:
            state.latitude  += random.uniform(-0.000008, 0.000008)
            state.longitude += random.uniform(-0.000008, 0.000008)
            state.altitude  += random.uniform(-0.08, 0.08)
        time.sleep(1.0)


# ----------------------------------------------------------------------
# ZIGBEE READER & SENDER (Linux /dev/ttyUSB0)
# ----------------------------------------------------------------------
def open_zigbee_port():
    """Try to open the primary port, fall back to alternatives if needed."""
    global ser

    ports_to_try = [XBEE_PORT] + FALLBACK_PORTS
    for p in ports_to_try:
        if not os.path.exists(p):
            continue
        try:
            ser = serial.Serial(p, XBEE_BAUD, timeout=1)
            print(f"ZigBee opened on {p} @ {XBEE_BAUD} baud")
            return True
        except Exception as e:
            print(f"Could not open {p}: {e}")

    print("ERROR: No ZigBee device found on any candidate port.")
    return False


def read_zigbee_corrections():
    """Open serial port and handle incoming/outgoing messages."""
    global ser

    if not open_zigbee_port():
        return

    pattern = re.compile(
        r'(?P<gun_id>\d+) '
        r'(?P<x>[\d\.\-]+) '
        r'(?P<y>[\d\.\-]+) '
        r'(?P<z>[\d\.\-]+)'
    )

    last_send_time = 0
    SEND_INTERVAL = 1.0

    while True:
        current_time = time.time()

        # ---- SEND heading every second ----
        if current_time - last_send_time >= SEND_INTERVAL:
            with state.lock:
                gun_id = state.gun_id
                heading = state.heading
            try:
                msg = f"{gun_id} {heading}\n"
                ser.write(msg.encode('utf-8'))
                print(f"Sent to ZigBee: {msg.strip()} (gun_id={gun_id}, heading={heading}°)")
                last_send_time = current_time
            except Exception as e:
                print(f"[ZigBee send error] {e}")

        # ---- READ incoming corrections ----
        try:
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()
                if not line:
                    continue

                print(f"Received ZigBee: {line}")

                m = pattern.fullmatch(line)
                if m:
                    gun_id = int(m.group('gun_id'))
                    if gun_id != 1:
                        print("   (ignored – gun_id is not 1)")
                        continue

                    x = float(m.group('x'))
                    y = float(m.group('y'))
                    z = float(m.group('z'))

                    with state.lock:
                        state.correction_x = x
                        state.correction_y = y
                        state.correction_z = z
                        state.gun_id = gun_id

                    print(f"   → Updated corrections X={x}, Y={y}, Z={z}")
                else:
                    print("   (ignored – does not match pattern)")

        except Exception as e:
            print(f"[ZigBee read error] {e}")

        time.sleep(0.05)


# ----------------------------------------------------------------------
# WEBSOCKET SERVER
# ----------------------------------------------------------------------
connected_clients = set()

async def handle_client(ws):
    global connected_clients
    connected_clients.add(ws)
    print(f"Client connected – {ws.remote_address}")

    try:
        # ----- command listener (SET) -----
        async def recv_cmd():
            try:
                async for msg in ws:
                    cmd = json.loads(msg)
                    if cmd.get('command') == 'SET':
                        with state.lock:
                            state.zero_pitch = state.raw_pitch
                            state.zero_roll  = state.raw_roll
                            state.zero_yaw   = state.raw_yaw
                            # Reset corrections so displayed values become 0°
                            state.correction_x = state.correction_y = state.correction_z = 0.0
                        print(f"SET pressed – Zero reference updated")
            except websockets.exceptions.ConnectionClosed:
                pass

        cmd_task = asyncio.create_task(recv_cmd())

        # ----- broadcast loop (1 Hz) -----
        while True:
            with state.lock:
                rel_pitch = (state.raw_pitch - state.zero_pitch) + state.correction_y
                rel_roll  = (state.raw_roll  - state.zero_roll)  + state.correction_x
                rel_yaw   = (state.raw_yaw   - state.zero_yaw)   + state.correction_z

                payload = {
                    "timestamp": datetime.now(UTC).isoformat() + "Z",
                    "gun_id": state.gun_id,
                    "imu": {
                        "pitch":   round(rel_pitch, 2),
                        "roll":    round(rel_roll, 2),
                        "yaw":     round(rel_yaw, 2),
                        "heading": round(state.heading, 2)
                    },
                    "gnss": {
                        "latitude":  round(state.latitude, 6),
                        "longitude": round(state.longitude, 6),
                        "altitude":  round(state.altitude, 1)
                    },
                    "corrections": {
                        "x": round(state.correction_x, 2),
                        "y": round(state.correction_y, 2),
                        "z": round(state.correction_z, 2)
                    },
                    "target": {
                        "pitch": round(state.correction_y, 2),
                        "roll":  round(state.correction_x, 2),
                        "yaw":   round(state.correction_z, 2)
                    }
                }

            await ws.send(json.dumps(payload))
            await asyncio.sleep(1.0)

    except websockets.exceptions.ConnectionClosed:
        print("Client disconnected")
    finally:
        connected_clients.discard(ws)


# ----------------------------------------------------------------------
# MAIN
# ----------------------------------------------------------------------
async def main():
    print("Artillery Pointing System Server (Linux)")
    print(f"WebSocket: ws://{HOST}:{PORT}")
    print(f"Update rate: {UPDATE_RATE_HZ} Hz")

    # Start background threads
    threading.Thread(target=read_imu_data, daemon=True).start()
    threading.Thread(target=read_gnss_data, daemon=True).start()
    threading.Thread(target=read_zigbee_corrections, daemon=True).start()

    async with websockets.serve(handle_client, HOST, PORT):
        await asyncio.Future()   # run forever


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nServer stopped")
    finally:
        if ser and ser.is_open:
            ser.close()